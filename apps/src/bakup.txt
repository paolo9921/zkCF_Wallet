/*impl SubjectPublicKeyInfo {
    pub fn take_from<S: decode::Source>(cons: &mut Constructed<S>) -> Result<Self, DecodeError<S::Error>> {
        cons.take_sequence(|cons| {
            let algorithm = AlgorithmIdentifier::take_from(cons)?;
            
            
            //let key_bytes = cons.take_primitive(|_, content| Ok(content.slice_all()?.to_vec()))?;
            let key_bytes = cons.capture_all()?.as_slice().to_vec();
            
            println!("\n key bytes {:?}",key_bytes);

            //check algorithm OID to parse either RSA key or ECDSA key
            let subject_public_key = if algorithm.algorithm.as_ref() == RSA_OID_BYTES {
                //let key_source = key_bytes[1..].into_source();
                //let key_source = key_bytes_trimmed.into_source();

                let public_key = Constructed::decode(key_bytes.into_source(), Mode::Der, |cons| {
                    
                    
                    cons.take_sequence(|cons| {
                        
                        let modulus = cons.take_value(|_, content| {
                            let mod_bytes = content.as_primitive()?.slice_all()?.to_vec();
                            let mut modu = mod_bytes.clone();
                            if modu[0] == 0 {
                                modu.remove(0);
                            }
                            Ok(modu)
                        })?;
                        
                        let exponent = cons.take_value(|_, content| {
                            let exp_bytes = content.as_primitive()?.slice_all()?.to_vec();
                            Ok(exp_bytes)
                        })?;
                        println!("\n\n[*] parsed RSA public key: [ mod:{:?}, exp: {:?}]\n",modulus,exponent);
                        Ok(PublicKey::Rsa { modulus, exponent })
                    })
                }).expect("failed to parse rsa public key\n");
                public_key

            } else if algorithm.algorithm.as_ref() == ECDSA_OID_BYTES {
                //let point = cons.capture_all()?.as_slice().to_vec();
                let point_bytes = &key_bytes[2..];
                println!("\n[*] parsed ECDSA key. point: {:?}",point_bytes);
                
                PublicKey::Ecdsa { point: point_bytes.to_vec() }

            } else {
                return Err(DecodeError::content("Unsupported algorithm", decode::Pos::default()));
            };

            Ok(SubjectPublicKeyInfo {
                algorithm,
                subject_public_key,
            })*/